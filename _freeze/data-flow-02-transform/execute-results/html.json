{
  "hash": "97fe580038d7ea7766dd1edfadb7b9d0",
  "result": {
    "markdown": "---\ntitle: Generation Transform\n---\n\nThe goal of this pipeline is to update a parquet file with generation data from the French grid.\n\nIn the **transform** step:\n\n- Parse response saved from the **ingest** step\n- Concatenate with existing parquet files\n- Write parquet files\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport os\nimport dvc.api\nimport json\nfrom datetime import datetime, timedelta\nfrom zoneinfo import ZoneInfo\nimport requests\nimport functools, itertools\nimport polars as pl\nfrom pyprojroot.here import here\n```\n:::\n\n\nFirst, let's read the parameters:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nparams = dvc.api.params_show(\"dvc-params.yaml\")\n```\n:::\n\n\nLet's load in the results from the previous step. \nWe also load the published results, so that we can append the current results.\nSimilar to the **ingest** step, we do not declare this file as a dependency, to avoid circularity.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nwith open(here(\"data/01-ingest/flow.json\"), \"r\") as file:\n    array = json.load(file)\n\nfile_existing = here(\"data/99-publish/standard/flow.parquet\")\ntable_existing = pl.DataFrame()\nif os.path.isfile(file_existing):\n    table_existing = pl.read_parquet(file_existing)\n```\n:::\n\n\nWe can use Polars to wrangle this data:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ntable = (\n    pl.DataFrame(array)\n    .select(\n        [\n            pl.col(\"sender_country_name\").alias(\"sender\"),\n            pl.col(\"receiver_country_name\").alias(\"receiver\"),\n            pl.col(\"values\"),\n        ]\n    )\n    .explode(\"values\")  # list of 24 hourly values\n    .unnest(\"values\")  # dict with start_date, end_date, value\n    .drop([\"updated_date\"])\n    .rename(\n        {\"start_date\": \"interval_start\", \"end_date\": \"interval_end\", \"value\": \"flow\"}\n    )\n    .with_columns(\n        [\n            pl.col(\"interval_start\")\n            .str.strptime(pl.Datetime(\"ms\"))\n            .dt.convert_time_zone(time_zone=params[\"tz_local\"]),\n            pl.col(\"interval_end\")\n            .str.strptime(pl.Datetime(\"ms\"))\n            .dt.convert_time_zone(time_zone=params[\"tz_local\"]),\n        ]\n    )\n    .sort([\"interval_start\"])\n)\n\ntable.head(6)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div><style>\n.dataframe > thead > tr > th,\n.dataframe > tbody > tr > td {\n  text-align: right;\n}\n</style>\n<small>shape: (6, 5)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>sender</th><th>receiver</th><th>interval_start</th><th>interval_end</th><th>flow</th></tr><tr><td>str</td><td>str</td><td>datetime[ms, Europe/Paris]</td><td>datetime[ms, Europe/Paris]</td><td>i64</td></tr></thead><tbody><tr><td>&quot;Germany&quot;</td><td>&quot;France&quot;</td><td>2017-06-28 00:00:00 CEST</td><td>2017-06-28 01:00:00 CEST</td><td>45</td></tr><tr><td>&quot;Belgium&quot;</td><td>&quot;France&quot;</td><td>2017-06-28 00:00:00 CEST</td><td>2017-06-28 01:00:00 CEST</td><td>719</td></tr><tr><td>&quot;France&quot;</td><td>&quot;Germany&quot;</td><td>2017-06-28 00:00:00 CEST</td><td>2017-06-28 01:00:00 CEST</td><td>0</td></tr><tr><td>&quot;France&quot;</td><td>&quot;Belgium&quot;</td><td>2017-06-28 00:00:00 CEST</td><td>2017-06-28 01:00:00 CEST</td><td>0</td></tr><tr><td>&quot;France&quot;</td><td>&quot;Italy&quot;</td><td>2017-06-28 00:00:00 CEST</td><td>2017-06-28 01:00:00 CEST</td><td>923</td></tr><tr><td>&quot;France&quot;</td><td>&quot;England-IFA&quot;</td><td>2017-06-28 00:00:00 CEST</td><td>2017-06-28 01:00:00 CEST</td><td>853</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\nThis gives us a tidy table we can work with.\n\nNote that for each time, a country-pair is observed twice, with `sender` and `receiver` reversed. \n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ntable.filter((pl.col(\"sender\") == \"Germany\") | (pl.col(\"receiver\") == \"Germany\")).head(\n    6\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n<div><style>\n.dataframe > thead > tr > th,\n.dataframe > tbody > tr > td {\n  text-align: right;\n}\n</style>\n<small>shape: (6, 5)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>sender</th><th>receiver</th><th>interval_start</th><th>interval_end</th><th>flow</th></tr><tr><td>str</td><td>str</td><td>datetime[ms, Europe/Paris]</td><td>datetime[ms, Europe/Paris]</td><td>i64</td></tr></thead><tbody><tr><td>&quot;Germany&quot;</td><td>&quot;France&quot;</td><td>2017-06-28 00:00:00 CEST</td><td>2017-06-28 01:00:00 CEST</td><td>45</td></tr><tr><td>&quot;France&quot;</td><td>&quot;Germany&quot;</td><td>2017-06-28 00:00:00 CEST</td><td>2017-06-28 01:00:00 CEST</td><td>0</td></tr><tr><td>&quot;Germany&quot;</td><td>&quot;France&quot;</td><td>2017-06-28 01:00:00 CEST</td><td>2017-06-28 02:00:00 CEST</td><td>55</td></tr><tr><td>&quot;France&quot;</td><td>&quot;Germany&quot;</td><td>2017-06-28 01:00:00 CEST</td><td>2017-06-28 02:00:00 CEST</td><td>0</td></tr><tr><td>&quot;Germany&quot;</td><td>&quot;France&quot;</td><td>2017-06-28 02:00:00 CEST</td><td>2017-06-28 03:00:00 CEST</td><td>0</td></tr><tr><td>&quot;France&quot;</td><td>&quot;Germany&quot;</td><td>2017-06-28 02:00:00 CEST</td><td>2017-06-28 03:00:00 CEST</td><td>20</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\nNote also that for each pair, there is at most one non-zero `flow`, and that `\"France\"` is always part of the transaction.\n\nWe can simplify this table by:\n\n  - combining `sender` and `receiver` into a replacement variable, `partner` (France becomes implied).\n  - we can replace `flow` with `flow_net`, if power is transmitted *to* France it would be positive.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ntable_net = (\n    table.with_columns(\n        [\n            pl.when(pl.col(\"sender\") == \"France\")\n            .then(pl.col(\"receiver\"))\n            .otherwise(pl.col(\"sender\"))\n            .alias(\"partner\"),\n            pl.when(pl.col(\"sender\") == \"France\")\n            .then(-pl.col(\"flow\"))\n            .otherwise(pl.col(\"flow\"))\n            .alias(\"flow_net\"),\n        ]\n    )\n    .groupby([\"partner\", \"interval_start\", \"interval_end\"])\n    .agg([pl.sum(\"flow_net\")])\n    .sort([\"interval_start\", \"partner\"])\n)\n\ntable_net.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=html}\n<div><style>\n.dataframe > thead > tr > th,\n.dataframe > tbody > tr > td {\n  text-align: right;\n}\n</style>\n<small>shape: (5, 4)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>partner</th><th>interval_start</th><th>interval_end</th><th>flow_net</th></tr><tr><td>str</td><td>datetime[ms, Europe/Paris]</td><td>datetime[ms, Europe/Paris]</td><td>i64</td></tr></thead><tbody><tr><td>&quot;Belgium&quot;</td><td>2017-06-28 00:00:00 CEST</td><td>2017-06-28 01:00:00 CEST</td><td>719</td></tr><tr><td>&quot;England-IFA&quot;</td><td>2017-06-28 00:00:00 CEST</td><td>2017-06-28 01:00:00 CEST</td><td>-853</td></tr><tr><td>&quot;Germany&quot;</td><td>2017-06-28 00:00:00 CEST</td><td>2017-06-28 01:00:00 CEST</td><td>45</td></tr><tr><td>&quot;Italy&quot;</td><td>2017-06-28 00:00:00 CEST</td><td>2017-06-28 01:00:00 CEST</td><td>-923</td></tr><tr><td>&quot;Switzerland&quot;</td><td>2017-06-28 00:00:00 CEST</td><td>2017-06-28 01:00:00 CEST</td><td>450</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\nLet's combine with the previous results, and remove duplicates:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ntable_combined = (\n    pl.concat([table_existing, table_net])\n    .unique(subset=[\"interval_start\", \"partner\"])\n    .sort(by=[\"interval_start\", \"partner\"])\n)\n```\n:::\n\n\nFor this table, for each partner, count the observations and null values.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ntable_combined.groupby([\"partner\"]).agg(\n    pl.col(\"interval_start\").min(),\n    pl.col(\"interval_end\").max(),\n    pl.col(\"flow_net\").count().alias(\"n_observations\"),\n    pl.col(\"flow_net\").null_count().alias(\"n_value_null\"),\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```{=html}\n<div><style>\n.dataframe > thead > tr > th,\n.dataframe > tbody > tr > td {\n  text-align: right;\n}\n</style>\n<small>shape: (6, 5)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>partner</th><th>interval_start</th><th>interval_end</th><th>n_observations</th><th>n_value_null</th></tr><tr><td>str</td><td>datetime[ms, Europe/Paris]</td><td>datetime[ms, Europe/Paris]</td><td>u32</td><td>u32</td></tr></thead><tbody><tr><td>&quot;Switzerland&quot;</td><td>2017-01-01 00:00:00 CET</td><td>2017-07-11 00:00:00 CEST</td><td>4574</td><td>0</td></tr><tr><td>&quot;Italy&quot;</td><td>2017-01-01 00:00:00 CET</td><td>2017-07-11 00:00:00 CEST</td><td>4574</td><td>0</td></tr><tr><td>&quot;Spain&quot;</td><td>2017-01-01 00:00:00 CET</td><td>2017-06-27 16:00:00 CEST</td><td>4254</td><td>0</td></tr><tr><td>&quot;Germany&quot;</td><td>2017-01-01 00:00:00 CET</td><td>2017-07-11 00:00:00 CEST</td><td>4574</td><td>0</td></tr><tr><td>&quot;Belgium&quot;</td><td>2017-01-01 00:00:00 CET</td><td>2017-07-11 00:00:00 CEST</td><td>4574</td><td>0</td></tr><tr><td>&quot;England-IFA&quot;</td><td>2017-01-01 00:00:00 CET</td><td>2017-07-11 00:00:00 CEST</td><td>4574</td><td>0</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\nFinally, write the result:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ntable_combined.write_parquet(here(\"data/02-transform/flow.parquet\"))\n```\n:::\n\n\n",
    "supporting": [
      "data-flow-02-transform_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}