{
  "hash": "78a76ad659ef036bfcb0e83f010c5359",
  "result": {
    "markdown": "---\ntitle: Generation Ingest\n---\n\nThe eventual goal is to update a parquet file with generation data from the French grid.\n\nThis is the **ingest** step:\n\n- Try to read a data file to get start date, use default otherwise.\n- Use minimum of today's date or start-date plus one month as end date.\n- Assemble query, execute for API\n\nThe generation data is available from 2017-01-01, onwards.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport os\nfrom datetime import datetime, timedelta\nfrom zoneinfo import ZoneInfo\nimport requests\nimport json\nimport functools, itertools\nimport polars as pl\nfrom pyprojroot.here import here\n```\n:::\n\n\nLet's determine the `start_date` and the `end_date` for the request:\n\n- the start date will be the larger of:\n\n  - 2017-01-01\n  - the most-recent date in the dataset, less a day\n\n- the end date will be the smaller of:\n  - the start date plus 14 days\n  - the current date\n\nDates are expressed as midnight, Paris time.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# these feel like parameters\ntz_local = ZoneInfo(\"Europe/Paris\")\n\n# not including this as a DVC dependency, as this would make things \"circular\"\nfile_transform_meta = here(\"data/99-publish/generation-meta.json\")\n\n# if file exists, get most-recent date\ndate_end_previous = None\nif os.path.isfile(file_transform_meta):\n    with open(file_transform_meta, \"r\") as file:\n        meta = json.load(file)\n        date_end_previous = datetime.fromisoformat(meta.get(\"interval_end\")).astimezone(\n            tz_local\n        )\n```\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# timedelta() seems to use periods rather than intervals;\n# i.e., it takes DST into account and returns same wall-clock time.\n\ndate_start = datetime(2017, 1, 1, tzinfo=tz_local)\nif date_end_previous is not None:\n    date_start = date_end_previous\n\ndate_end = date_start + timedelta(days=14)\n\n# amend date_end if in the future\ndate_today = datetime.now(tz_local).replace(hour=0, minute=0, second=0, microsecond=0)\ndate_end = min(date_end, date_today)\n```\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nprint(date_start.isoformat())\nprint(date_end.isoformat())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2017-02-26T00:00:00+01:00\n2017-03-12T00:00:00+01:00\n```\n:::\n:::\n\n\nThen, let's request a token:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nauth = requests.post(\n    \"https://digital.iservices.rte-france.com/token/oauth/\",\n    headers={\n        \"Authorization\": f'Basic {os.environ[\"RTE_FRANCE_BASE64\"]}',\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\n    },\n)\ntoken = auth.json()[\"access_token\"]\n```\n:::\n\n\nWe compose a request, gather the response, then pull out the data:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nendpoint = \"https://digital.iservices.rte-france.com/open_api/actual_generation/v1/generation_mix_15min_time_scale\"\n\nresponse = requests.get(\n    f\"{endpoint}/?start_date={date_start.isoformat()}&end_date={date_end.isoformat()}\",\n    headers={\n        \"Host\": \"digital.iservices.rte-france.com\",\n        \"Authorization\": f\"Bearer {token}\",\n    },\n)\n```\n:::\n\n\nCheck the response:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nresponse.ok\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nTrue\n```\n:::\n:::\n\n\nIf the response is OK, write out JSON content to file:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nif response.ok:\n    array = response.json()[\"generation_mix_15min_time_scale\"]\n\n    with open(here(\"data/01-ingest/generation.json\"), \"w\") as file:\n        json.dump(array, file)\n```\n:::\n\n\n",
    "supporting": [
      "data-generation-01-ingest_files"
    ],
    "filters": [],
    "includes": {}
  }
}