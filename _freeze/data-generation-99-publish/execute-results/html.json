{
  "hash": "76831b27746a15957e441b0444286894",
  "result": {
    "markdown": "---\ntitle: Generation Publish\n---\n\nIn the **publish** step:\n\n- Write out data as parquet files in \"standard\" and \"fake UTC\" formats.\n- Write out metadata as a JSON file.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport os\nimport polars as pl\nfrom pyprojroot.here import here\nimport json\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ntable = pl.read_parquet(here(\"data/02-transform/generation.parquet\"))\n```\n:::\n\n\nJavaScript does not (yet) have a timezone database available; you can use the timezone of the browser, or you can use UTC.\nThe idea here is to use a \"fake UTC\", by projecting the date-times from their original timezone (`Europe/Paris`) to UTC, preserving the wall-clock time.\nThis will help us with any date-time math in JavaScript, but with the price of introducing a gap and a duplication at the daylight-saving time transitions. \n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ntable_fake_utc = table.with_columns(\n    pl.col([\"interval_start\", \"interval_end\"]).map(\n        lambda x: x.dt.replace_time_zone(time_zone=\"UTC\")\n    ),\n)\n```\n:::\n\n\nWe publish both the standard and fake-UTC tables:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\npath_standard = here(\"data/99-publish/standard\")\nos.makedirs(path_standard, exist_ok=True)\ntable.write_parquet(f\"{path_standard}/generation.parquet\")\n```\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\npath_fake_utc = here(\"data/99-publish/fake-utc\")\nos.makedirs(path_fake_utc, exist_ok=True)\ntable_fake_utc.write_parquet(f\"{path_fake_utc}/generation.parquet\")\n```\n:::\n\n\nWe also calculate and write out some metadata:\n\n - `interval_end`: latest observation for each `type`, then aggregated using earliest of these.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ninterval_end = (\n    table.groupby(pl.col(\"type\"))\n    .agg(pl.col(\"interval_end\").max())\n    .get_column(\"interval_end\")\n    .min()\n)\n```\n:::\n\n\nWe publish this to a metadata file:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndict = {\"interval_end\": interval_end.isoformat()}\n\nwith open(here(\"data/99-publish/generation-meta.json\"), \"w\") as file:\n    json.dump(dict, file)\n```\n:::\n\n\n",
    "supporting": [
      "data-generation-99-publish_files"
    ],
    "filters": [],
    "includes": {}
  }
}